using Distributions
using Interpolations 
using DSP
using Plots


#----------------------------------------------------------------------
# Generate optimised time vectors to calculate kinetic traces over
#----------------------------------------------------------------------

"""
Returns unique steps in vector `t`.
"""
function getTimeSteps(t)
    # round to avoid machine precision inaccuracies
    unique(round.(diff(t); digits=14))
end


"""
Returns time vector for ODE solver `tOde` given an input `t`
in which all time points have equal spacing. 

Extends `t` by additional points, which will be discarded after 
calculating the kinetic trace to avoid edge effect over the 
original time range.
"""
function getOdeTimeConstantStep(t, μ, σ)
    # time steps; round to avoid machine precision inaccuracies
    tSteps = getTimeSteps(t)
    # check constant time step
    @assert length(tSteps) == 1

    tStep = tSteps[1]


    # final extended time point
    tExtFinal = t[end]+4σ-μ
    # extend t by additional points
    tExt = t[end]+tStep:tStep:tExtFinal
    # extended time range; equal to t if tExtFinal < t[end]
    tOde = vcat(collect.([t, tExt])...)

    return (tOde,)

end


"""
Returns time vector for ODE solver `tOde` given an input `t`
in which time points have arbitrary spacing.

`tOde` contains early time points with equal spacing, used for convolution
with the instrument response, and arbitrarily spaced points at later
times where effect of instrument response is negligible.
"""
function getOdeTimeVariableStep(t, μ, σ)
    # time steps; round to avoid machine precision inaccuracies
    tSteps = unique(round.(diff(t); digits=14))
    # check variable time step
    @assert length(tSteps) > 1

    # time step in irf window is smallest time step in dataset
    irfStep = minimum(tSteps)
    # IRF window width in pos/neg direction
    tMaxIrf = 30*σ
    # evenly spaced time steps for convolution
    # need one point after tMaxIrf in case interpolation is queried between final step and tMaxIrf
    tConv = getOdeTimeConstantStep(irfStep/2:irfStep:tMaxIrf+irfStep, μ, σ)[1]

    # time steps post convolution; shift post-irf time by -μ to 
    # evaluate correct points for original time vector in ODE
    tPostConv = t[t .≥ tMaxIrf] .- μ
    
    # combine irf and post-irf times in array for single call to ODE solver
    tOde = sort(unique([tConv; tPostConv]))

    # keep track of which time in tOde vector is IRF/post-IRF; some 
    # may be in both
    tConvBl = in.(tOde, Ref(Set(tConv)))
    tPostConvBl = in.(tOde, Ref(Set(t .- μ)))
    
    return (tOde, tConv, tMaxIrf, tConvBl, tPostConvBl)

end


"""
Returns vector over which to calculate kinetic traces
based on `t`, optimised for a Gaussian IRF with centre `μ` and
standard deviation `σ`, and automatically taking care of 
`t` spacing. 
"""
function getOdeTime(t, μ, σ)
    tSteps = getTimeSteps(t)

    # constant time spacing
    if length(tSteps) == 1
        return getOdeTimeConstantStep(t, μ, σ)
    # variable time spacing
    else
        return getOdeTimeVariableStep(t, μ, σ)
    end
end


#----------------------------------------------------------------------
# Convolution of kinetic trace(s) and IRF
#----------------------------------------------------------------------


"""
Performs numerical integration of `y` over `x` via trapezoidal method.
"""
function trapezIntegration(x, y) 
    # x and y must have same length
    @assert length(x) == length(y)
    out = 0.0
    for n in 2:length(x)
      out += 0.5*(x[n] - x[n-1])*(y[n] + y[n-1])
    end
    return out
end


"""
Generates Gaussian over vector `t`, centred around `μ` with 
standard deviation `σ`.
"""
function getGaussianIRF(t, μ, σ)
    # get Gaussian
    irf = pdf.(Normal(μ, σ), t)
    return irf
end


"""
Convolves vectors `kin` and `irf`, where `kin` contains 
data for `t ≥ 0` only and must be evenly spaced in `t`. 
`t` contains positive and negative time points, `irf` 
is calculated over full `t`.

`kin` can be a single kinetic trace or a matrix consisting of
multiple kinetic traces as columns.
"""
function convolveIrfConstantStep(t, kin, irf, tSteps) 

    @assert length(tSteps) == 1
    @assert length(t) == length(irf)
    tStep = tSteps[1]

    # normalise IRF by its area
    irf ./= trapezIntegration(t,irf)

    # discrete convolution, hence multiply by time step
    kinConv = DSP.conv(kin, irf) .* tStep

    # make convolved data same length as IRF data to restore 
    # time correspondence
    kinConvSame = selectdim(kinConv, 1, 1:length(t))

    return kinConvSame

end



"""
Convolves vectors `kin` and a Gaussian IRF with centre `μ` and
standard deviation `σ`. `kin` is contains data for `t ≥ 0` only 
and can be arbitrarily spaced in `t`. `t` contains positive and 
negative time points. `tStepParam` is generated by `getOdeTime`.

`kin` can be a single kinetic trace or a matrix consisting of
multiple kinetic traces as columns. These kinetic traces can be
of arbitrary reaction order.

To convolve a kinetic traces with variable time spacing, the kinetic
trace is calculated over an evenly spaced early time period and then
interpolated back onto the early portion of the original `t` vector. 
Later times, at whichthe effect of the instrument response is 
negiligible, are appended tothe convolved data without convolution.
"""
function convolveIrfVariableStep(t, kin, μ, σ, tSteps, tStepParam)

    @assert length(tSteps) > 1

    tOde, tConv, tMaxIrf, tConvBl, tPostConvBl = tStepParam

    # mirror evenly spaced times around zero
    tIrf = [reverse(-tConv); tConv]
    # generate IRF
    irf = getGaussianIRF(tIrf, μ, σ)

    # convolve evenly spaced part of kinetic trace
    kinConv = convolveIrfConstantStep(tIrf, selectdim(kin,1,tConvBl), 
        irf, [minimum(tSteps)])

    # number of kinetic traces
    numKin = size(kin,2)

    # interpolator for convolved trace
    # single kinetic trace
    if numKin == 1
        itpKinConv = interpolate((tIrf,), kinConv, Gridded(Linear()))
    # multiple kinetic traces
    else
        # no interpolation along second dimension 
        itpKinConv = interpolate((tIrf,1:numKin,), kinConv, 
            (Gridded(Linear()),NoInterp()))
    end


    # interpolation back onto original time vector
    # single kinetic trace
    if numKin == 1
        kinConvFinal = [zeros(length(t[t .< -tMaxIrf])); 
            itpKinConv(t[-tMaxIrf .≤ t .< tMaxIrf]); 
            kin[tPostConvBl]]
    # multiple kinetic traces
    else
        kinConvFinal = [zeros(length(t[t .< -tMaxIrf]),numKin); 
            itpKinConv(t[-tMaxIrf .≤ t .< tMaxIrf],1:numKin); 
            kin[tPostConvBl,:]]
    end

    return kinConvFinal

end


"""
Convolves vectors `kin` and a Gaussian IRF with centre `μ` and
standard deviation `σ`, automatically taking care of `t` spacing.
For variable `t` spacing, `tStepParam` must be supplied from
`getOdeTime`.
"""
function convolveIRF(t, kin, μ, σ, tStepParam)

    tSteps = getTimeSteps(t)

    # constant time spacing
    if length(tSteps) == 1    
        # generate IRF
        irf = getGaussianIRF(t, μ, σ)
        return convolveIrfConstantStep(t, kin, irf, tSteps) 
    # variable time spacing
    else
        return convolveIrfVariableStep(t, kin, μ, σ, tSteps, tStepParam)
    end

end



