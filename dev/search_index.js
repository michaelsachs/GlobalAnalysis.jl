var documenterSearchIndex = {"docs":
[{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The kinetic model module offers the flexibility to specify custom kinetic models of any reaction order to extract the spectral signatures of physical species from experimental datasets.","category":"page"},{"location":"kineticModel/#Model-definition","page":"Kinetic model","title":"Model definition","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"We define kinetic models in the form of reaction networks as implemented in Catalyst.jl. DifferentialEquations.jl then generates the differential equations that describe the reaction network, optimizes them for simulation, and solves them numerically.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"To illustrate the use of reaction networks, consider a Michaelis-Menten enzyme-catalyzed reaction:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"S + E undersetk_2oversetk_1rightleftharpoons ES xrightarrowk_3 P + E","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The enzyme E reacts with a substrate S to form an enzyme-substrate complex ES. ES can convert to E and product P, completing the enzymatic reaction, or decompose back to S and E. These reactions can be formulated as the following reaction network:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"rn = @reaction_network begin\n    k1, S + E --> SE\n    k2, SE --> S + E\n    k3, SE --> P + E\nend","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Note that each reaction has been assigned a rate constant k1, k2, or k3. In this way, use of the @reaction_network macro facilitates simple configuration of complicated reaction models. ","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"To numerically solve differential equations, we need the following pieces of information:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The concentrations of the species involved in the reaction at the start of the simulation, typically chosen to be t = 0\nThe values of the involved rate constants\nThe time span over which to solve the differential equations","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Let's choose a set of parameters for these values:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"# initial conditions\nu0 = [:S => 300, :E => 100, :SE => 0, :P => 0] \n\n# rate constants\np = [:k1 => 0.001, :k2 => 0.0001, :k3 => 0.1]\n\n# time span\ntspan = [0, 100]","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"After solving the differential equations generated from the reaction network we obtain the following reaction kinetics, showing the temporal evolution of the individual species' concentrations:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Some further examples of how to set up reaction networks can be found in the Examples section below. More detailed information is available in the documentation of Catalyst.jl.","category":"page"},{"location":"kineticModel/#Instrument-response-function","page":"Kinetic model","title":"Instrument response function","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"While we can simulate our reaction kinetics to infinite time resolution, an experimental setup imposes a finite time resolution. To accurately reproduce experimental data, we therefore need to take into account the instrument response function (IRF) of the system.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"IRFs are often approximated as a Gaussian with a defined center μ and standard deviation σ, defining its position and width in time, respectively. This Gaussian is then convolved with the kinetic traces obtained from the differential equation solver. In the resulting convolved traces, μ controls when signal onset occurs and σ determines how sharply the signal sets on. Here, we can optimize both μ and σ as part of our within our fitting procedure.","category":"page"},{"location":"kineticModel/#Fitting-procedure","page":"Kinetic model","title":"Fitting procedure","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The kinetic module performs a global fit of a 2D dataset, which can be described as described as follows:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"psi(tgamma) = sum_l=1^n_comp c_l(t) epsilon_l(gamma)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Here, psi(tgamma) is the spectally and time resolved data, c_l(t) is the population of species l at time t, and epsilon_l(gamma) is the spectral spectral signature of component l at energy/wavelength/wavenumber gamma. ","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The global analysis procedure involves the following steps:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Choose a kinetic model. Use the @reaction_network macro to define a kinetic model.\nGenerate kinetic traces. Differential equations are generated from the reaction network and solved numerically.\nIRF convolution. The kinetic traces are convolved with a Gaussian instrument response. \nRecover spectral signatures. The spectral signature for each simulated kinetic trace are produced from the experimental data using matrix division.\nIterative optimization. Parameters, rate constants, and instrument response parameters are varied iteratively to maximise the fit between simulated and experimental data.\nRefine kinetic model. Tune the kinetic model based on physical intuition and fit quality.","category":"page"},{"location":"kineticModel/#Examples","page":"Kinetic model","title":"Examples","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"To illustrate the use of different kinetic models, we look at examples where we recover spectral signatures from synthetic data. For the purpose of these examples, we generate data comprising three different species. We first generate spectral signatures for our synthetic species, representing positive, negative, and mixed positive/negative signatures:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/#Example:-First-order-sequential-model","page":"Kinetic model","title":"Example: First-order sequential model","text":"","category":"section"},{"location":"kineticModel/#Assembling-synthetic-data","page":"Kinetic model","title":"Assembling synthetic data","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"We define a set of first order reaction kinetics where species A converts to B, B converts to C, and C decays to the ground state:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"A xrightarrowk_1 B xrightarrowk_2 C xrightarrowk_3 0","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The corresponding reaction network looks as follows:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"# define kinetic model\nrn = @reaction_network begin\n    k1, A --> B\n    k2, B --> C\n    k3, C --> 0\nend","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Next we choose initial amplitudes, rate constants, and instrument response function parameters. Given the sequential nature of the reaction, A is initialised to 1, whereas B and C are initialised to 0. We set the rate constants in decreasing order k1 = 1, k2 = 0.1, k3 = 0.01 as otherwise no buildup of species B and C is observed. Finally, we use a Gaussian as an IRF with an offset of μ = 0.2 and a standard deviation of σ = 0.1.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":" Dict(\n    :A => 1,\n    :B => 0,\n    :C => 0,\n    :k1 => 1,\n    :k2 => 0.1,\n    :k3 => 0.01,\n    :μ => 0.2,\n    :σ => 0.1\n)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"From these parameters, we obtain the following kinetic traces:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"By matrix multiplying spectral signatures and kinetic traces, we generate a 2D dataset, which is the sum of the temporal evolutions of all three spectral components. In addition, some noise is added to replicate experimental conditions more closely. This dataset can be found in \\data\\testData_first_order_seq.csv.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/#Global-fit","page":"Kinetic model","title":"Global fit","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The recovery of spectral signatures and experimental parameters from the generated synthetic dataset is shown in the example notebook /notebooks/kineticModel.ipynb.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"For a global fit, we assume a kinetic model and test how well it fits the experimental data. Here, we know the used sequential model and thus define the reaction network rn and the initial amplitudes of the involved species as above. In the case of a reaction network composed solely of first order reactions, reaction rates are independent of the species' populations, meaning that it only matters whether a component is initialised with 0 or a non-zero value. ","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Next, we define parameter bounds for the rate constants k1, k2, and k3. In the case of a sequential reaction, this typically involves adjacent parameter ranges as below. Similarly, we define parameter bounds for the IRF center μ, reflecting the onset of the signal with respect to t = 0, and the standard deviation σ, reflecting the width of the IRF.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"limits = Dict(\n    :A => 1,\n    :B => 0,\n    :C => 0,\n    :k1 => [5e-1, 5],\n    :k2 => [5e-2, 5e-1],\n    :k3 => [5e-3, 5e-2],\n    :μ => [-0.5, 0.5],\n    :σ => [0.04, 0.2]\n)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"To run the global fit, we define the maximum number of iterations in the fit, for example maxIter = 200 for 200 iterations, and then run the optimization routine. To judge whether an optimal solution has been found, we can monitor the convergence of the fit. Here, the chosen number of iterations resulted in 2000 function evaluations with no changes for the second half of those evaluations, which is a good indication that the fit has converged.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The fit returns the following parameters, demonstrating that the input parameters have been recovered successfully. Returned parameters are in the order of rate constants and then IRF parameters, e.g. in this case k1, k2, k3, μ, σ.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":" 0.9973429786752928\n 0.10034827965186788\n 0.010001260582309495\n 0.1995665861641629\n 0.09967374660755733","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The optimized kinetics are essentially identical to the input above:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The optimized spectra closely resemble the input, except for the noise added to the synthetic dataset:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/#Example:-Mixed-order-parallel-model","page":"Kinetic model","title":"Example: Mixed-order parallel model","text":"","category":"section"},{"location":"kineticModel/#Assembling-synthetic-data-2","page":"Kinetic model","title":"Assembling synthetic data","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"GlobalAnalysis.jl allows to perform a global fit involving non-first order reactions. In this example, we generate another synthetic dataset comprised of one first, one second, and one third order reaction. For example, common second and third order reactions for photogenerated charges are bimolecular recombination and Auger recombination, respectively. ","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"We define the following reaction network, in which all three reactions proceed in parallel:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"# define kinetic model\nrn = @reaction_network begin\n    k1, A --> 0\n    k2, 2B --> 0\n    k3, 3C --> 0\nend","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Unlike for first order reactions, the reaction rates of higher order reactions depend on the carrier concentration. As such, we need to assign physically meaningful initial carrier concentrations for our species in order to obtain physically meaningful rate constants. For example, let's assume we generate A, B, and C with initial concentrations of 1e17 cm^-3 - a common value for laser experiments. ","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"1e17 cm^-3 is a rather large number and may cause numerical difficulties, but we can convert it to a more manageable 1e5 mu m^-3. Assuming that our time axis is in ps, we choose rate constants of 1 ps^-1 for the first-order k1, 1e-5 mu m^3 ps^-1 for the second-order k2, and 1e-9 mu m^6 ps^-1 for the third-order k3. The IRF parameters are the same as in the previous example.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Dict(\n    :A => 1e5,\n    :B => 1e5,\n    :C => 1e5,\n    :k1 => 1,\n    :k2 => 1e-5,\n    :k3 => 1e-9,\n    :μ => 0.2,\n    :σ => 0.1\n)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"This reaction network and parameters yield the following kinetic traces:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"We use the same spectral signatures as above to generate a synthetic 2D dataset, again with added noise. The resulting dataset can be found in \\data\\testData_mixed_order_par.csv.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/#Global-fit-2","page":"Kinetic model","title":"Global fit","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"To set up the global fit, we first define our parameter bounds. These include the known initial concentration 1e5 mu m^-3 of our species A, B, and C - for real data these can be estimated from the absorption of the studied sample and the used laser fluence. We provide expected ranges for the rate constants and IRF parameters, again keeping in mind the units defined by our initial concentrations and the time axis.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"limits = Dict(\n    :A => 1e5,\n    :B => 1e5,\n    :C => 1e5,\n    :k1 => [0.5, 5],\n    :k2 => [1e-4, 1e-6],\n    :k3 => [1e-10, 1e-8],\n    :μ => [-0.5, 0.5],\n    :σ => [0.04, 0.2]\n)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"With maxIter = 300, we achieve a satisfactory convergence:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The input kinetics are recovered reliably:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Similarly, the spectral signatures are recovered, with an additional scaling factor arising from a normalization of the 2D data to keep the amplitudes in the data comparable to the first order example.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"(Image: Alt text)","category":"page"},{"location":"kineticModel/#Fixed-parameters","page":"Kinetic model","title":"Fixed parameters","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Parameters in the limits dictionary can be fitted or fixed. A fit parameter is defined as a range of two numbers, setting the upper and lower bound for the fit. A fixed parameter is supplied as a single value.","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"For example, let's take the first-order sequential model above and assume we know that k2 = 0.1. k2 can therefore be included as a single value in limits, indicating that it has a fixed value:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"limits = Dict(\n    :A => 1,\n    :B => 0,\n    :C => 0,\n    :k1 => [5e-1, 5],\n    # k2 now fixed\n    :k2 => 0.1, \n    :k3 => [5e-3, 5e-2],\n    :μ => [-0.5, 0.5],\n    :σ => [0.04, 0.2]\n)","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The returned fit parameters are now k1, k3, μ, σ:","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":" 0.9987864025253465\n 0.010011635105851064\n 0.19962871764921578\n 0.09973821246066149","category":"page"},{"location":"kineticModel/#Model-refinement","page":"Kinetic model","title":"Model refinement","text":"","category":"section"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"Refining a kinetic model is an iterative process. It is often necessary to test several different models as well as different parameter bounds in order to achieve an satisfactory fit. ","category":"page"},{"location":"kineticModel/","page":"Kinetic model","title":"Kinetic model","text":"The kinetic model notebook produces residual maps, illustrating the difference between the the achieved fit and the experimental data. In the ideal case the residual map will only contain noise, as the fit fully captures the features in the experimental data. If features are observed in the residual maps this means there are aspects of the data not captured by the used kinetic model within the chosen parameter bounds, and the amplitude of these residual features can be used to guide the refinement of the model and/or its parameters. ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"These setup instructions assume no prior Julia installation and will walk you through the steps to set up Julia, a code editor, and GlobalAnalysis.jl.","category":"page"},{"location":"installation/#Installing-Julia","page":"Installation","title":"Installing Julia","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download the current stable Julia release from https://julialang.org/downloads/ and install it. Note down the path of the Julia executable as we will need it later; e.g., under Windows this could be C:\\Users\\Michael\\Julia\\Julia-1.9.4\\bin\\julia.exe.","category":"page"},{"location":"installation/#Setting-up-VS-Code","page":"Installation","title":"Setting up VS Code","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"A convenient way to take advantage of Julia's multithreading capabilities in Jupyter notebooks is to run them in the code editor Visual Studio Code. ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Download VS Code from https://code.visualstudio.com/Download and install it. Next, we will install the Julia extension in VS Code. Start VS Code and click on Extensions in the left menu bar. Search for julia and then click to install the official extension:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(Image: \"VS Code screenshot showing the Julia extension\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Finally, we will point VS Code to our Julia installation and enable multithreading. To this end, go to File > Preferences > Settings from the top menu bar in VS code. ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Executable path. In the search bar, enter julia executable, which should bring up Julia: Executable Path. Here, paste the path you have noted during the Julia installation.\nMulithreading. In the search bar, enter julia threads, which should bring up Julia: Num Threads. Click on Edit in settings.json. This step takes you to a file called settings.json, where you will find \"julia.NumThreads\" with some default value assigned. Replace the default value with the number of threads on your machine (typically twice the number of cores), if you know it; for example, \"julia.NumThreads\": 16 for a machine with 8 cores. If you do not know this information, use \"julia.NumThreads\": \"auto\" to automatically detect how many threads to use.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"VS Code and Julia are now set up. To verify that everything is working, you can press Ctrl + Shift + P (Windows/Linux) / Shift + Command + P (Mac) to bring up the command palette, and look for Julia: Start REPL. Selecting this option will bring up Julia's terminal within VS Code, indicated by the appearance of a green julia>. You can enter a simple command like 1 + 2, which should return the expected result.","category":"page"},{"location":"installation/#Setting-up-GlobalAnalysis.jl","page":"Installation","title":"Setting up GlobalAnalysis.jl","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Go to Source Control in the left menu bar and click Clone Repository. If Clone Repository is not available, you will be prompted to Download Git, which is required to work with repositories: follow the shown link and download and install Git - during the installation process, you can keep the default selected options. After restarting VS Code, Clone Repository should be available.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(Image: \"VS Code screenshot showing the Julia extension\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"A window appears at the top; paste https://github.com/michaelsachs/GlobalAnalysis.jl here\nA popup window asks where you want to save the repository folder. Pick any directory you like and click Select as Repository Destination\nA popup asks whether you want to open the new repository. Click Open\nPress Ctrl + Shift + P (Windows/Linux) / Shift + Command + P (Mac) to bring up the command palette, and look for Julia: Start REPL\nPress ] to switch to the package manager \nType instantiate and press enter. This will download and precompile all required packages, which may take a few minutes\nIn the file explorer (top icon in the left menu bar), navigate to the notebooks folder and select the notebook you want to run\nFor example, select kineticModel.ipynb an click Run all to ensure everything is working. If you are prompted to choose a kernel, select Julia and then the Julia version you have installed in the previous step","category":"page"},{"location":"import/#File-format","page":"Data import","title":"File format","text":"","category":"section"},{"location":"import/","page":"Data import","title":"Data import","text":"Experimental data should be formatted as a .csv file, where:","category":"page"},{"location":"import/","page":"Data import","title":"Data import","text":"The first column (second entry onwards) is the spectral dimension, e.g. wavelength/wavenumbers/energy/etc.\nThe first row (second entry onwards) is the temporal dimension\nThe first value of the dataset (first column, first row) is unused; for example, it can be set to 0\nThe rest of the file are amplitudes of the 2-dimensional spectro-temporal data","category":"page"},{"location":"import/","page":"Data import","title":"Data import","text":"An example dataset can be found in \\data\\testData_first_order_seq.csv.","category":"page"},{"location":"import/#Data-import","page":"Data import","title":"Data import","text":"","category":"section"},{"location":"import/","page":"Data import","title":"Data import","text":"Data is read from .csv files using importData(path), where path can point either to a single .csv file or a folder.  ","category":"page"},{"location":"import/","page":"Data import","title":"Data import","text":"If path points to a folder, all .csv files contained in it are imported\nIf path points to a .csv file, only this file is imported","category":"page"},{"location":"import/","page":"Data import","title":"Data import","text":"In both cases, importData returns a StructArray, containing one or more elements depending on how many .csv files were imported. The imported data can be accessed as follows:","category":"page"},{"location":"import/","page":"Data import","title":"Data import","text":"# define .csv file containing experimental data\nfile = raw\"C:\\GlobalAnalysis.jl\\data\\testData_mixed_order_par.csv\"\n# import data, pick first dataset\ndata = importData(file)[1]\n\n# spectral dimension\ns = data.x\n# time dimension\nt = data.y\n# 2D data\nd = data.z","category":"page"},{"location":"#GlobalAnalysis.jl","page":"Home","title":"GlobalAnalysis.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GlobalAnalysis.jl","category":"page"}]
}
