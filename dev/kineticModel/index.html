<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kinetic model · GlobalAnalysis.jl</title><meta name="title" content="Kinetic model · GlobalAnalysis.jl"/><meta property="og:title" content="Kinetic model · GlobalAnalysis.jl"/><meta property="twitter:title" content="Kinetic model · GlobalAnalysis.jl"/><meta name="description" content="Documentation for GlobalAnalysis.jl."/><meta property="og:description" content="Documentation for GlobalAnalysis.jl."/><meta property="twitter:description" content="Documentation for GlobalAnalysis.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GlobalAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../import/">Data import</a></li><li class="is-active"><a class="tocitem" href>Kinetic model</a><ul class="internal"><li><a class="tocitem" href="#Model-definition"><span>Model definition</span></a></li><li><a class="tocitem" href="#Instrument-response-function"><span>Instrument response function</span></a></li><li><a class="tocitem" href="#Fitting-procedure"><span>Fitting procedure</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Example:-First-order-sequential-model"><span>Example: First-order sequential model</span></a></li><li><a class="tocitem" href="#Example:-Mixed-order-parallel-model"><span>Example: Mixed-order parallel model</span></a></li><li><a class="tocitem" href="#Fixed-parameters"><span>Fixed parameters</span></a></li><li><a class="tocitem" href="#Model-refinement"><span>Model refinement</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Kinetic model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Kinetic model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/michaelsachs/GlobalAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/michaelsachs/GlobalAnalysis.jl/blob/main/docs/src/kineticModel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>The kinetic model module offers the flexibility to specify custom kinetic models of any reaction order to extract the spectral signatures of physical species from experimental datasets.</p><h2 id="Model-definition"><a class="docs-heading-anchor" href="#Model-definition">Model definition</a><a id="Model-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Model-definition" title="Permalink"></a></h2><p>We define kinetic models in the form of reaction networks as implemented in <em>Catalyst.jl</em>. <em>DifferentialEquations.jl</em> then generates the differential equations that describe the reaction network, optimizes them for simulation, and solves them numerically.</p><p>To illustrate the use of reaction networks, consider a Michaelis-Menten enzyme-catalyzed reaction:</p><p class="math-container">\[S + E \underset{k_{2}}{\overset{k_1}{\rightleftharpoons}} ES \xrightarrow{k_3} P + E\]</p><p>The enzyme <code>E</code> reacts with a substrate <code>S</code> to form an enzyme-substrate complex <code>ES</code>. <code>ES</code> can convert to <code>E</code> and product <code>P</code>, completing the enzymatic reaction, or decompose back to <code>S</code> and <code>E</code>. These reactions can be formulated as the following reaction network:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    k1, S + E --&gt; SE
    k2, SE --&gt; S + E
    k3, SE --&gt; P + E
end</code></pre><p>Note that each reaction has been assigned a rate constant <code>k1</code>, <code>k2</code>, or <code>k3</code>. In this way, use of the <code>@reaction_network</code> macro facilitates simple configuration of complicated reaction models. </p><p>To numerically solve differential equations, we need the following pieces of information:</p><ul><li>The concentrations of the species involved in the reaction at the start of the simulation, typically chosen to be <code>t = 0</code></li><li>The values of the involved rate constants</li><li>The time span over which to solve the differential equations</li></ul><p>Let&#39;s choose a set of parameters for these values:</p><pre><code class="language-julia hljs"># initial conditions
u0 = [:S =&gt; 300, :E =&gt; 100, :SE =&gt; 0, :P =&gt; 0] 

# rate constants
p = [:k1 =&gt; 0.001, :k2 =&gt; 0.0001, :k3 =&gt; 0.1]

# time span
tspan = [0, 100]</code></pre><p>After solving the differential equations generated from the reaction network we obtain the following reaction kinetics, showing the temporal evolution of the individual species&#39; concentrations:</p><p><img src="../figures/Michaelis_menten_kinetics.svg" alt="Alt text"/></p><p>Some further examples of how to set up reaction networks can be found in the <em>Examples</em> section below. More detailed information is available in the <a href="https://docs.sciml.ai/Catalyst/stable/catalyst_functionality/dsl_description/">documentation of <em>Catalyst.jl</em></a>.</p><h2 id="Instrument-response-function"><a class="docs-heading-anchor" href="#Instrument-response-function">Instrument response function</a><a id="Instrument-response-function-1"></a><a class="docs-heading-anchor-permalink" href="#Instrument-response-function" title="Permalink"></a></h2><p>While we can simulate our reaction kinetics to infinite time resolution, an experimental setup imposes a finite time resolution. To accurately reproduce experimental data, we therefore need to take into account the instrument response function (IRF) of the system.</p><p>IRFs are often approximated as a Gaussian with a defined center <span>$μ$</span> and standard deviation <span>$σ$</span>, defining its position and width in time, respectively. This Gaussian is then convolved with the kinetic traces obtained from the differential equation solver. In the resulting convolved traces, <span>$μ$</span> controls when signal onset occurs and <span>$σ$</span> determines how sharply the signal sets on. Here, we can optimize both <span>$μ$</span> and <span>$σ$</span> as part of our within our fitting procedure.</p><h2 id="Fitting-procedure"><a class="docs-heading-anchor" href="#Fitting-procedure">Fitting procedure</a><a id="Fitting-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-procedure" title="Permalink"></a></h2><p>The kinetic module performs a global fit of a 2D dataset, which can be described as described as follows:</p><p class="math-container">\[\psi(t,\gamma) = \sum_{l=1}^{n_{comp}} c_l(t) \epsilon_l(\gamma)\]</p><p>Here, <span>$\psi(t,\gamma)$</span> is the spectally and time resolved data, <span>$c_l(t)$</span> is the population of species <span>$l$</span> at time <span>$t$</span>, and <span>$\epsilon_l(\gamma)$</span> is the spectral spectral signature of component <span>$l$</span> at energy/wavelength/wavenumber <span>$\gamma$</span>. </p><p>The global analysis procedure involves the following steps:</p><ol><li><strong>Choose a kinetic model.</strong> Use the <code>@reaction_network</code> macro to define a kinetic model.</li><li><strong>Generate kinetic traces.</strong> Differential equations are generated from the reaction network and solved numerically.</li><li><strong>IRF convolution.</strong> The kinetic traces are convolved with a Gaussian instrument response. </li><li><strong>Recover spectral signatures.</strong> The spectral signature for each simulated kinetic trace are produced from the experimental data using matrix division.</li><li><strong>Iterative optimization.</strong> Parameters, rate constants, and instrument response parameters are varied iteratively to maximise the fit between simulated and experimental data.</li><li><strong>Refine kinetic model.</strong> Tune the kinetic model based on physical intuition and fit quality.</li></ol><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>To illustrate the use of different kinetic models, we look at examples where we recover spectral signatures from synthetic data. For the purpose of these examples, we generate data comprising three different species. We first generate spectral signatures for our synthetic species, representing positive, negative, and mixed positive/negative signatures:</p><p><img src="../figures/Synthetic_spectral_signatures.svg" alt="Alt text"/></p><h2 id="Example:-First-order-sequential-model"><a class="docs-heading-anchor" href="#Example:-First-order-sequential-model">Example: First-order sequential model</a><a id="Example:-First-order-sequential-model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-First-order-sequential-model" title="Permalink"></a></h2><h3 id="Assembling-synthetic-data"><a class="docs-heading-anchor" href="#Assembling-synthetic-data">Assembling synthetic data</a><a id="Assembling-synthetic-data-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-synthetic-data" title="Permalink"></a></h3><p>We define a set of first order reaction kinetics where species <code>A</code> converts to <code>B</code>, <code>B</code> converts to <code>C</code>, and <code>C</code> decays to the ground state:</p><p class="math-container">\[A \xrightarrow{k_1} B \xrightarrow{k_2} C \xrightarrow{k_3} 0\]</p><p>The corresponding reaction network looks as follows:</p><pre><code class="language-julia hljs"># define kinetic model
rn = @reaction_network begin
    k1, A --&gt; B
    k2, B --&gt; C
    k3, C --&gt; 0
end</code></pre><p>Next we choose initial amplitudes, rate constants, and instrument response function parameters. Given the sequential nature of the reaction, <code>A</code> is initialised to <code>1</code>, whereas <code>B</code> and <code>C</code> are initialised to <code>0</code>. We set the rate constants in decreasing order <code>k1 = 1</code>, <code>k2 = 0.1</code>, <code>k3 = 0.01</code> as otherwise no buildup of species <code>B</code> and <code>C</code> is observed. Finally, we use a Gaussian as an IRF with an offset of <code>μ = 0.2</code> and a standard deviation of <code>σ = 0.1</code>.</p><pre><code class="language-julia hljs"> Dict(
    :A =&gt; 1,
    :B =&gt; 0,
    :C =&gt; 0,
    :k1 =&gt; 1,
    :k2 =&gt; 0.1,
    :k3 =&gt; 0.01,
    :μ =&gt; 0.2,
    :σ =&gt; 0.1
)</code></pre><p>From these parameters, we obtain the following kinetic traces:</p><p><img src="../figures/Synthetic_first_order_kinetics.svg" alt="Alt text"/></p><p>By matrix multiplying spectral signatures and kinetic traces, we generate a 2D dataset, which is the sum of the temporal evolutions of all three spectral components. In addition, some noise is added to replicate experimental conditions more closely. This dataset can be found in <code>\data\testData_first_order_seq.csv</code>.</p><p><img src="../figures/Synthetic_first_order_data.svg" alt="Alt text"/></p><h3 id="Global-fit"><a class="docs-heading-anchor" href="#Global-fit">Global fit</a><a id="Global-fit-1"></a><a class="docs-heading-anchor-permalink" href="#Global-fit" title="Permalink"></a></h3><p>The recovery of spectral signatures and experimental parameters from the generated synthetic dataset is shown in the example notebook <code>/notebooks/kineticModel.ipynb</code>.</p><p>For a global fit, we assume a kinetic model and test how well it fits the experimental data. Here, we know the used sequential model and thus define the reaction network <code>rn</code> and the initial amplitudes of the involved species as above. In the case of a reaction network composed solely of first order reactions, reaction rates are independent of the species&#39; populations, meaning that it only matters whether a component is initialised with <code>0</code> or a non-zero value. </p><p>Next, we define parameter bounds for the rate constants <code>k1</code>, <code>k2</code>, and <code>k3</code>. In the case of a sequential reaction, this typically involves adjacent parameter ranges as below. Similarly, we define parameter bounds for the IRF center <code>μ</code>, reflecting the onset of the signal with respect to <code>t = 0</code>, and the standard deviation <code>σ</code>, reflecting the width of the IRF.</p><pre><code class="language-julia hljs">limits = Dict(
    :A =&gt; 1,
    :B =&gt; 0,
    :C =&gt; 0,
    :k1 =&gt; [5e-1, 5],
    :k2 =&gt; [5e-2, 5e-1],
    :k3 =&gt; [5e-3, 5e-2],
    :μ =&gt; [-0.5, 0.5],
    :σ =&gt; [0.04, 0.2]
)</code></pre><p>To run the global fit, we define the maximum number of iterations in the fit, for example <code>maxIter = 200</code> for 200 iterations, and then run the optimization routine. To judge whether an optimal solution has been found, we can monitor the convergence of the fit. Here, the chosen number of iterations resulted in 2000 function evaluations with no changes for the second half of those evaluations, which is a good indication that the fit has converged.</p><p><img src="../figures/First_order_convergence.svg" alt="Alt text"/></p><p>The fit returns the following parameters, demonstrating that the input parameters have been recovered successfully. Returned parameters are in the order of rate constants and then IRF parameters, e.g. in this case <code>k1</code>, <code>k2</code>, <code>k3</code>, <code>μ</code>, <code>σ</code>.</p><pre><code class="nohighlight hljs"> 0.9973429786752928
 0.10034827965186788
 0.010001260582309495
 0.1995665861641629
 0.09967374660755733</code></pre><p>The optimized kinetics are essentially identical to the input above:</p><p><img src="../figures/First_order_fit_kinetics.svg" alt="Alt text"/></p><p>The optimized spectra closely resemble the input, except for the noise added to the synthetic dataset:</p><p><img src="../figures/First_order_fit_spectra.svg" alt="Alt text"/></p><h2 id="Example:-Mixed-order-parallel-model"><a class="docs-heading-anchor" href="#Example:-Mixed-order-parallel-model">Example: Mixed-order parallel model</a><a id="Example:-Mixed-order-parallel-model-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Mixed-order-parallel-model" title="Permalink"></a></h2><h3 id="Assembling-synthetic-data-2"><a class="docs-heading-anchor" href="#Assembling-synthetic-data-2">Assembling synthetic data</a><a class="docs-heading-anchor-permalink" href="#Assembling-synthetic-data-2" title="Permalink"></a></h3><p>GlobalAnalysis.jl allows to perform a global fit involving non-first order reactions. In this example, we generate another synthetic dataset comprised of one first, one second, and one third order reaction. For example, common second and third order reactions for photogenerated charges are bimolecular recombination and Auger recombination, respectively. </p><p>We define the following reaction network, in which all three reactions proceed in parallel:</p><pre><code class="language-julia hljs"># define kinetic model
rn = @reaction_network begin
    k1, A --&gt; 0
    k2, 2B --&gt; 0
    k3, 3C --&gt; 0
end</code></pre><p>Unlike for first order reactions, the reaction rates of higher order reactions depend on the carrier concentration. As such, we need to assign physically meaningful initial carrier concentrations for our species in order to obtain physically meaningful rate constants. For example, let&#39;s assume we generate <code>A</code>, <code>B</code>, and <code>C</code> with initial concentrations of 1e17 <span>$cm^{-3}$</span> - a common value for laser experiments. </p><p>1e17 <span>$cm^{-3}$</span> is a rather large number and may cause numerical difficulties, but we can convert it to a more manageable 1e5 <span>$\mu m^{-3}$</span>. Assuming that our time axis is in ps, we choose rate constants of 1 <span>$ps^{-1}$</span> for the first-order <code>k1</code>, 1e-5 <span>$\mu m^{3} ps^{-1}$</span> for the second-order <code>k2</code>, and 1e-9 <span>$\mu m^{6} ps^{-1}$</span> for the third-order <code>k3</code>. The IRF parameters are the same as in the previous example.</p><pre><code class="language-julia hljs">Dict(
    :A =&gt; 1e5,
    :B =&gt; 1e5,
    :C =&gt; 1e5,
    :k1 =&gt; 1,
    :k2 =&gt; 1e-5,
    :k3 =&gt; 1e-9,
    :μ =&gt; 0.2,
    :σ =&gt; 0.1
)</code></pre><p>This reaction network and parameters yield the following kinetic traces:</p><p><img src="../figures/Synthetic_mixed_order_kinetics.svg" alt="Alt text"/></p><p>We use the same spectral signatures as above to generate a synthetic 2D dataset, again with added noise. The resulting dataset can be found in <code>\data\testData_mixed_order_par.csv</code>.</p><p><img src="../figures/Synthetic_mixed_order_data.svg" alt="Alt text"/></p><h3 id="Global-fit-2"><a class="docs-heading-anchor" href="#Global-fit-2">Global fit</a><a class="docs-heading-anchor-permalink" href="#Global-fit-2" title="Permalink"></a></h3><p>To set up the global fit, we first define our parameter bounds. These include the known initial concentration 1e5 <span>$\mu m^{-3}$</span> of our species <code>A</code>, <code>B</code>, and <code>C</code> - for real data these can be estimated from the absorption of the studied sample and the used laser fluence. We provide expected ranges for the rate constants and IRF parameters, again keeping in mind the units defined by our initial concentrations and the time axis.</p><pre><code class="language-julia hljs">limits = Dict(
    :A =&gt; 1e5,
    :B =&gt; 1e5,
    :C =&gt; 1e5,
    :k1 =&gt; [0.5, 5],
    :k2 =&gt; [1e-4, 1e-6],
    :k3 =&gt; [1e-10, 1e-8],
    :μ =&gt; [-0.5, 0.5],
    :σ =&gt; [0.04, 0.2]
)</code></pre><p>With <code>maxIter = 300</code>, we achieve a satisfactory convergence:</p><p><img src="../figures/Mixed_order_convergence.svg" alt="Alt text"/></p><p>The input kinetics are recovered reliably:</p><p><img src="../figures/Mixed_order_fit_kinetics.svg" alt="Alt text"/></p><p>Similarly, the spectral signatures are recovered, with an additional scaling factor arising from a normalization of the 2D data to keep the amplitudes in the data comparable to the first order example.</p><p><img src="../figures/Mixed_order_fit_spectra.svg" alt="Alt text"/></p><h2 id="Fixed-parameters"><a class="docs-heading-anchor" href="#Fixed-parameters">Fixed parameters</a><a id="Fixed-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-parameters" title="Permalink"></a></h2><p>Parameters in the <code>limits</code> dictionary can be fitted or fixed. A fit parameter is defined as a range of two numbers, setting the upper and lower bound for the fit. A fixed parameter is supplied as a single value.</p><p>For example, let&#39;s take the first-order sequential model above and assume we know that <code>k2 = 0.1</code>. <code>k2</code> can therefore be included as a single value in <code>limits</code>, indicating that it has a fixed value:</p><pre><code class="language-julia hljs">limits = Dict(
    :A =&gt; 1,
    :B =&gt; 0,
    :C =&gt; 0,
    :k1 =&gt; [5e-1, 5],
    # k2 now fixed
    :k2 =&gt; 0.1, 
    :k3 =&gt; [5e-3, 5e-2],
    :μ =&gt; [-0.5, 0.5],
    :σ =&gt; [0.04, 0.2]
)</code></pre><p>The returned fit parameters are now <code>k1</code>, <code>k3</code>, <code>μ</code>, <code>σ</code>:</p><pre><code class="nohighlight hljs"> 0.9987864025253465
 0.010011635105851064
 0.19962871764921578
 0.09973821246066149</code></pre><h2 id="Model-refinement"><a class="docs-heading-anchor" href="#Model-refinement">Model refinement</a><a id="Model-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Model-refinement" title="Permalink"></a></h2><p>Refining a kinetic model is an iterative process. It is often necessary to test several different models as well as different parameter bounds in order to achieve an satisfactory fit. </p><p>The kinetic model notebook produces residual maps, illustrating the difference between the the achieved fit and the experimental data. In the ideal case the residual map will only contain noise, as the fit fully captures the features in the experimental data. If features are observed in the residual maps this means there are aspects of the data not captured by the used kinetic model within the chosen parameter bounds, and the amplitude of these residual features can be used to guide the refinement of the model and/or its parameters. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../import/">« Data import</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 18 December 2023 07:52">Monday 18 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
